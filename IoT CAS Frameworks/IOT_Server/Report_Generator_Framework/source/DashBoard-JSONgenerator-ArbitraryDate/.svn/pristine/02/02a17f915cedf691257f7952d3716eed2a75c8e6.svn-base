/**
 * *********************************************************************
 * Software Developed by Merit Systems Pvt. Ltd., No. 42/1, 55/c, Nandi Mansion,
 * 40th Cross, Jayanagar 8th Block Bangalore - 560 070, India Work Created for
 * Merit Systems Private Limited All rights reserved
 *
 * THIS WORK IS SUBJECT TO INDIAN AND INTERNATIONAL COPYRIGHT LAWS AND TREATIES
 * NO PART OF THIS WORK MAY BE USED, PRACTICED, PERFORMED, COPIED, DISTRIBUTED,
 * REVISED, MODIFIED, TRANSLATED, ABRIDGED, CONDENSED, EXPANDED, COLLECTED,
 * COMPILED, LINKED, RECAST, TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN
 * CONSENT ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
 * SUBJECT THE PERPETRATOR TO CRIMINAL AND CIVIL LIABILITY.
 * *********************************************************************
 */
package com.merit.dashboard.queryexecuter;

import java.io.IOException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedHashMap;
import org.apache.log4j.Logger;
import org.json.JSONArray;
import org.json.JSONObject;

import com.merit.connection.ConnectionDAO;
import main.ServiceThreadListener;
import com.merit.dashboard.Availability.GetAvailability;
import com.merit.dashboard.DBUtil.DBUtilHelper;
import com.merit.dashboard.bizlogic.BizLogic;
import com.merit.dashboard.model.PojoObject;
import com.merit.dashboard.util.ResourceConfiguration;
import java.lang.reflect.Method;
import java.text.DecimalFormat;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.Set;

/**
 * *****************************************************************************************************
 * All Status name with Count of each status,All Assignee Name with Count of
 * each Assignee, All Task-Summay with Count of each task-Summay in a single row
 * with distinct IP(ServerName or Host). Default Assignee, Status, task-summary
 *
 * *****************************************************************************************************
 */
public class QueryExecuter {

    static Logger log = Logger.getLogger(QueryExecuter.class);
//    Statement stat = null;
//    Connection uniqueconnection = null;
    BizLogic bizlogic = new BizLogic();
    public static PojoObject pojoObject = null;
    LinkedHashMap<String, String> ticketInfo = null;
    LinkedHashMap<String, String> serviceMetricInfo = null;

    /**
     * **************************************************************************************************
     * This method is creating Query to get necessay information to generate
     * chart from these tables like gatasktypeassignee and gatask.
     *
     * Query is generated to keep in mind like: 1.One IP in one Row, All
     * information related to this IP should be present in that row 2.For
     * generating Alert information in DashBoard these count is required:
     * Task-Summary count, Status count,Assignee Count
     *
     * These all above count's query, Joining with the help of left outer join
     * and we are using user_defined/InBuilt function like array_agg() for
     * concatenating a column and gives array for generating JSON. array_agg
     * function in postgresql below 8 version we have to create by following
     * command:
     *
     * create aggregate array_agg ( sfunc = array_append, basetype = anyelement,
     * stype = anyarray, initcond = '{}' );
     *
     * @param customer Selected customerId
     * @param resourceType Different category as
     * Desktop,Server,DataBase,Network,JVM
     * @param date from date as subtract(endDate-timestampselection) in Date
     * Format
     * @param date1 Current date in Date Format
     * @return ticketInfo Ticket generated Information
     *
     *  **************************************************************************************************
     */
    public LinkedHashMap<String, String> collectTicketdata(String customer, String resourceType, String cCustomer, String service,
            String date, String date1, String selection) throws IOException, SQLException {
        ticketInfo = new LinkedHashMap<String, String>();
        try {
//            uniqueconnection = ConnectionDAO.getConnection(customer + "");
//            stat = uniqueconnection.createStatement();

            String szQuery = "";

            if (selection.equals("CriticalAlerts")) {
                szQuery = "select servicename as ServiceName,resourcetype as ResourceType,host as ServerName,"
                        + "array_to_string(array_agg(summaryname),',') as ResourceNames,array_to_string(array_agg(summarycount),',') "
                        + "as ResourceValues,case when sum(criticalcheck)>0 then 'CRITICAL' else 'OK' end as Health,"
                        + "resourceid as ResourceID from (select count(*) as summarycount,attributes6 as host,"
                        + "attributes10 as resourcetype,attributes4 as ServiceName,attributes12 as resourceID,"
                        + "substring(task_summary from position('[' in task_summary) for 25) as summaryname,"
                        + "CASE WHEN substring(task_summary from position('[' in task_summary) for 25) like '%HSTDWN%' THEN 1 ELSE 0 END "
                        + "as criticalcheck from gatask where created_date between  '" + date + "' and '" + date1 + "' and "
                        + "status!='Closed' and task_type!='SOX' and attributes10='" + resourceType + "' and attributes4='" + service
                        + "' group by attributes6,summaryname,attributes4,attributes12,attributes10) as cAlert group by servicename, "
                        + "resourcetype, host,resourceid";
            } else if (selection.equals("AlertsByAssignee")) {
                szQuery = "select servicename as ServiceName,resourcetype as ResourceType,host as ServerName,"
                        + "array_to_string(array_agg(assigneenames),',') as ResourceNames,array_to_string(array_agg(ticketcount),',') "
                        + "as ResourceValues,case when host is not null then 'OK' end as Health,resourceid as ResourceID from "
                        + "(select count(*)as ticketcount,g2.attributes6 as host ,g2.attributes10 as resourcetype ,g2.attributes4 "
                        + "as ServiceName,g1.assignee as assigneenames,g2.attributes12 as ResourceID from gatask g2 ,"
                        + "gatasktypeassignee g1 where created_date between  '" + date + "' and '" + date1 + "' and "
                        + "g1.taskid=g2.task_id and action_assignee=1 and g2.attributes10='" + resourceType
                        + "' and attributes4='" + service + "' group by g2.attributes6,g1.assignee,attributes4,g2.attributes10,g2.attributes12) as assig "
                        + "group by servicename, resourcetype, host,resourceid";
            } else {
                szQuery = "select servicename as ServiceName,resourcetype as ResourceType,host as ServerName,"
                        + "array_to_string(array_agg(statusnames),',') as ResourceNames,array_to_string(array_agg(statuscount),',') "
                        + "as ResourceValues,case when host is not null then 'OK' end as Health,resourceid as ResourceID from "
                        + "(select count(*) as statuscount,attributes6 as host,attributes10 as resourcetype,attributes4 as "
                        + "ServiceName,status as statusnames,attributes12 as resourceID from gatask where created_date between  '"
                        + date + "' and '" + date1 + "' and attributes6!='none' and attributes10='" + resourceType + "' and "
                        + "attributes4='" + service + "' and attributes10!='none' and attributes6 is not null and attributes12 is not null group by attributes6,"
                        + "attributes4,status,attributes10,attributes12) as sAlert group by servicename, resourcetype, host,resourceid";
            }

            /**
             * ***************************************************************************************************
             * This Query will give Modified result from all necessary tables
             * like gatasktypeassignee, gatask table .. here concatenating the
             * result came from GAtask for Summary Count and checking hostdown
             * status array_agg function in postgresql below 8 version we have
             * to create by following command: create aggregate array_agg (
             * sfunc = array_append, basetype = anyelement, stype = anyarray,
             * initcond = '{}' );
             * ***************************************************************************************************
             */
            System.out.println("Ticket Query /" + resourceType + "/\n" + szQuery);
            log.debug("Ticket Query /" + resourceType + "/\n" + szQuery);

            ResultSet rs = ConnectionDAO.executerQuery(szQuery, customer);//stat.executeQuery(szQuery);

            while (rs.next()) {
                String alertCount = "[]";
                String alertName = "";
                String alertHealth = "[]";
                String nameOfAlert = "";
                String serverName = rs.getString("ServerName");
                String resourceID = rs.getString("ResourceID");
                String serviceName = rs.getString("ServiceName");
                resourceType = rs.getString("ResourceType");

                /**
                 * ************************************************************************************************
                 * Default Assignee that having no Ticket Assigned for specific
                 * host
                 * ************************************************************************************************
                 *
                 */
                String sz_query_assignee_list = "select distinct(user_id) as status from gaoperator where user_id !='Admin' "
                        + "and user_id!='None' and  user_id not in (select g1.assignee from gatask g2 ,"
                        + "gatasktypeassignee g1 where  created_date between '" + date + "' and '" + date1 + "'  and "
                        + "g1.taskid=g2.task_id and action_assignee=1 and g2.attributes10='" + resourceType
                        + "' and attributes4='" + service + "' and attributes4='" + service + "'  and attributes6='" + serverName + "') order by user_id";
                String assigneeList = getDefaultAssigneeStatus(sz_query_assignee_list, customer);

                /**
                 * Default Status for specific host
                 */
                String sz_query_status_list = " select distinct(status) as status from gastatus where status not in "
                        + "(select status from gatask where created_date between '" + date + "' and '" + date1
                        + "'  and attributes6!='none' and attributes10='" + resourceType + "' and attributes4='" + service + "' and attributes4='" + service + "' and attributes4='" + service
                        + "'  and attributes10!='none' and  attributes6 is not null and  attributes12 is not null   and attributes6='" + serverName + "')"
                        + " order by status";
                String statusList = getDefaultAssigneeStatus(sz_query_status_list, customer);

                if (rs.getString("ResourceValues") != null) {
                    alertCount = "[" + rs.getString("ResourceValues") + "]";
                }
                if (rs.getString("ResourceNames") != null) {
                    alertName = "\'" + rs.getString("ResourceNames").replace(",", "\',\'") + "\'";
                }
                if (rs.getString("Health") != null) {
                    alertHealth = "[\"" + rs.getString("Health") + "\"]";
                }
                if (selection.equals("AlertsByAssignee")) {
                    if (alertName.equals("")) {
                        nameOfAlert = "[" + assigneeList.substring(1) + "]";
                    } else {
                        //nameOfAlert = "[" + alertName + assigneeList + "]";
                        String tmpName = alertName.replaceAll("\'", "\"");
                        nameOfAlert = "[" + tmpName + assigneeList + "]";
                    }

                } else if (selection.equals("AlertsByStatus")) {
                    if (alertName.equals("")) {
                        nameOfAlert = "[" + statusList.substring(1) + "]";
                    } else {
                        //nameOfAlert = "[" + alertName + statusList + "]";
                        String tmpName = alertName.replaceAll("\'", "\"");
                        nameOfAlert = "[" + tmpName + statusList + "]";
                    }

                }
                String summaryname1 = "";
                String summarynameconcat = "";

                /**
                 * **************************************************************************************************
                 * Default Task Summary accepted from properties: File name is
                 * TaskSummay.Properties For specific resourceType and Checking
                 * Task-Summary is present or not. if present then changing from
                 * the properties(MetricMapping.prperties) file
                 * **************************************************************************************************
                 */
                if (selection.equals("CriticalAlerts")) {

                    String[] splitsummaryname = alertName.split(",");
                    if (splitsummaryname.length > 0 && !splitsummaryname[0].equalsIgnoreCase("")) {
                        for (int b = 0; b < splitsummaryname.length; b++) {
                            System.out.println("splitsummaryname==>>" + splitsummaryname[b]);
                            if (resourceType.equals("server")) {
                                if (!splitsummaryname[b].toLowerCase().contains("fnsp") && !splitsummaryname[b].toLowerCase().contains("tem")) {
                                    //System.out.println("183>>>>splitsummaryname[b] = " + splitsummaryname[b] + ", DBUtilHelper.getMetrics_mapping_properties().getProperty(splitsummaryname[b]) = " + DBUtilHelper.getMetrics_mapping_properties().getProperty(splitsummaryname[b]).trim());
                                    summarynameconcat = summarynameconcat + ",\"" + DBUtilHelper.getMetrics_mapping_properties().getProperty(splitsummaryname[b]).trim() + "\"";
                                }
                            } else {
                                summarynameconcat = summarynameconcat + ",\"" + DBUtilHelper.getMetrics_mapping_properties().getProperty(splitsummaryname[b]).trim() + "\"";
                            }
                        }

                        summarynameconcat = summarynameconcat.substring(1);
                        summaryname1 = summarynameconcat;
                    }

                    /**
                     * **************************************************************************************************
                     * Changing Task-Summary Name Present in
                     * Properties(TaskSummary.properties) with some useful
                     * meaning from other properties(MetricMapping.properties)
                     * files
                     * **************************************************************************************************
                     *
                     */
                    String[] szArrayCriticalNames = DBUtilHelper.getProperties().getProperty(resourceType).split(",");
                    for (int c = 0; c < szArrayCriticalNames.length; c++) {
                        if (!summaryname1.contains(DBUtilHelper.getMetrics_mapping_properties().getProperty(szArrayCriticalNames[c]).trim())) {
                            summaryname1 = summaryname1 + ",\"" + DBUtilHelper.getMetrics_mapping_properties().getProperty(szArrayCriticalNames[c]).trim() + "\"";
                        }
                    }
                }
                if (selection.equals("CriticalAlerts")) {
                    nameOfAlert = "[" + summaryname1 + "]";
                }

                /**
                 * Generating Map for Chart Generation
                 */
                ticketInfo.put(serverName + "," + resourceID, "\"ServiceName\":\"" + serviceName + "\",\"ResourceType\":\"" + resourceType + "\",\"ServerName\":\"" + serverName + "\",\"ResourceNames\":" + nameOfAlert + ",\"ResourceValues\":" + alertCount + ",\"SlaValues\":[10000],\"Health\":" + alertHealth + ",\"ResourceID\":\"" + resourceID + "\"");
                //ticketInfo.put(host+","+resourceId,"\"ServerName\":\""+host+"\",\"ServiceName\":\""+serviceName+"\",\"ResourceID\":\""+resourceId+"\",\"ResourceType\":\""+resourceType+"\",\"summarycount\":"+summarycount+",\"summaryname\":"+criticalSummaryName+",\"hstdwnstatus\":"+hstdwnstatus+",\"ticketcount\":"+ticketcount+",\"assigneenames\":"+assigneenames+",\"statusnames\":"+statusnames+",\"statuscount\":"+statuscount);
            }
            ConnectionDAO.closeStatement();

            if (ticketInfo.isEmpty()) {
                ticketInfo.put("DefaultMapValue", "\"summarycount\":[],\"summaryname\":[],\"hstdwnstatus\":[],\"ticketcount\":[],\"assigneenames\":[],\"statusnames\":[],\"statuscount\":[]");
            }
        } catch (Exception e) {
            e.printStackTrace();
            log.error("DashBoard Ticket Query /" + resourceType + "/\n" + e.getMessage());
        } finally {
        }
        return ticketInfo;
    }

    /**
     * ***************************************************************************************************
     * This method is returning the String of all Default values like
     * Status,Assignee that having no data but we have to show while generating
     * chart
     *
     * @param szExecuteQuery Query to be Executed
     * @param uniqueconnection Providing unique connection
     * @return szExecutedString gives output as string
     *
     * ***************************************************************************************************
     */
    public String getDefaultAssigneeStatus(String szExecuteQuery, String customer) throws IOException, SQLException {
        String szExecutedString = "";
        try {
//            stat = uniqueconnection.createStatement();
            ResultSet rs2 = ConnectionDAO.executerQuery(szExecuteQuery, customer);//stat.executeQuery(szExecuteQuery);
            while (rs2.next()) {
                szExecutedString = szExecutedString + ",\"" + rs2.getString("status") + "\"";
            }
            //uniqueconnection=null;
            ConnectionDAO.closeStatement();
        } catch (Exception e) {
            e.printStackTrace();
            log.error("DashBoard Ticket Assignee-Status Query \n" + e.getMessage());
        }
        return szExecutedString;
    }

    /**
     * ************************************************************************************************
     * This method is giving All metricType,Avg(Metricvalues) related to each
     * metricType, SLAValues related to each
     * metricType,services,ResourceType,ResourceId,Servername
     *
     * @param customer Selected customerID
     * @param resourceType Different category as
     * Desktop,Server,DataBase,Network,JVM
     * @param smilli date in second as long Timestamp(Current Time-selected Time
     * Period)
     * @param emilli date in second as long Timestamp(Current Time)
     * @return serviceMetricInfo Metric information as string Json
     *
     * *************************************************************************************************
     */
    public LinkedHashMap<String, String> collectMetricdata(String customer, String resourceType, String cCustomer, String service,
            String metrictypeIn, long smilli, long emilli) throws IOException, SQLException {
        try {
            pojoObject = new PojoObject();
            serviceMetricInfo = new LinkedHashMap<String, String>();
            ArrayList<String> host_resourcetype_list = new ArrayList<String>();
            serviceMetricInfo.clear();

            /**
             * *************************************************************************************************
             * Here we are checking the condition of showing critical according
             * to avg (means avg of actual value compare with avg of actual sla)
             * or Count (means actual value compare with actual sla)
             * *************************************************************************************************
             *
             */
            String metricHealthCheckLogic = "case when sum(criticalflag)>0 then 'CRITICAL' else 'OK' end";
            if (DBUtilHelper.getMetrics_mapping_properties().getProperty("HealthCheck").equals("AVG")) {
                metricHealthCheckLogic = "case when (avg(metricvalue)>avg(sla) and metrictype not in (" + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger") + ")) or (avg(metricvalue)<avg(sla) and metrictype in (" + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger") + ")) then  'CRITICAL' else 'OK' end";
            }

//            uniqueconnection = ConnectionDAO.getConnection(customer);
//            stat = uniqueconnection.createStatement();


            /**
             * ***************************************************************************************************
             * Here Query is Separated according to resource type because server
             * and Desktop taking more time because of more data , We can use
             * the same query by removing if condition array_agg function in
             * postgresql below 8 version we have to create by following
             * command: create aggregate array_agg ( sfunc = array_append,
             * basetype = anyelement, stype = anyarray, initcond = '{}' );
             * ***************************************************************************************************
             *
             */
            String szQuery = "select host,service,resourcetype,resourceid,array_to_string(array_agg(metricvalue),',') as metricvalues,"
                    + "array_to_string(array_agg(sla),',') as slavalues ,array_to_string(array_agg(metrictype),',') as metricname,"
                    + "array_to_string(array_agg(criticalsum),',') as metrictypehealth,resourceSubType from "
                    + "( select def.resourcesubtype as resourceSubType,f1.host,case when  f1.host=def.host and "
                    + "f1.resourceid=def.resourceid then def.service end as service,resourcetype,f1.resourceid,metricvalue,"
                    + "metrictype,sla,criticalsum from ( select host,service,resourcetype,resourceid,case when metrictype in ("
                    + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetrictypeCountAsValue") + ") then count(metrictype) "
                    + "else   round(cast(avg(metricvalue) as numeric),2) end as metricvalue,metrictype,round(cast(avg(sla) as numeric),2)"
                    + " as sla, " + metricHealthCheckLogic + " as criticalsum from ( select host,service,resourcetype,resourceid, "
                    + "metricvalue,metrictype,sla,case when metricvalue>sla and metrictype not in ("
                    + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger") + ") "
                    + "or metricvalue<sla and metrictype  in (" + DBUtilHelper.getMetrics_mapping_properties().getProperty(
                    "MetricTypeBelowThresholdIsDanger") + ") then 1 else 0  end as criticalflag from servicemetrics "
                    + "where timestamp1 between " + smilli + " and " + emilli + " and  "
                    + "resourcetype='" + resourceType + "' and "
                    + "customerid=(select id from customerinfo where customername='" + cCustomer + "') and "
                    + "service='" + service + "' and "
                    + "metrictype in (" + metrictypeIn + ") and "
                    + "metricvalue is not null and "
                    + "metrictype not in ('downtime'," + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetrictypeNotUsedInChart") + ")) as f "
                    + "group by host,service,resourcetype,resourceid,metrictype "
                    + "order by criticalsum) as f1 "
                    + "left outer join "
                    + "(select distinct host,resourceid,service,resourcesubtype from "
                    + "servicemetrics "
                    + "where resourcetype='" + resourceType + "' and "
                    + "customerid=(select id from customerinfo where customername='" + cCustomer + "') and "
                    + "service='" + service + "' and "
                    + "metrictype in (" + metrictypeIn + ") and "
                    + "service <>'null' and "
                    + "resourcesubtype !='') as def using(host,resourceid)) as s1 "
                    + "group by host,service,resourcetype,resourceid,resourcesubtype order by metrictypehealth";
            if (resourceType.equals("Desktop") || resourceType.equals("server")) {
                szQuery = "select host,service,resourcetype,resourceid,array_to_string(array_agg(metricvalue),',') as metricvalues,array_to_string(array_agg(sla),',') as slavalues ,array_to_string(array_agg(metrictype),',') as metricname,array_to_string(array_agg(criticalsum),',') as metrictypehealth from "
                        + "( select host,resourcetype, service,al.resourceid,metricvalue,metrictype,sla,criticalsum from "
                        + "( select service,resourceid,case when metrictype in (" + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetrictypeCountAsValue") + ") then count(metrictype) else   round(cast(avg(metricvalue) as numeric),2) end as metricvalue,metrictype,round(cast(avg(sla) as numeric),2) as sla, " + metricHealthCheckLogic + " as criticalsum from "
                        + "( select service,resourceid, metricvalue,metrictype,sla,case when metricvalue>sla and metrictype not in (" + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger") + ") or metricvalue<sla and metrictype in (" + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger") + ") then 1 else 0  end as criticalflag from "
                        + "servicemetrics "
                        + "where timestamp1 between " + smilli + " and " + emilli + " and  "
                        + "resourcetype='" + resourceType + "' and "
                        + "customerid=(select id from customerinfo where customername='" + cCustomer + "') and "
                        + "service='" + service + "' and "
                        + "metrictype in (" + metrictypeIn + ") and "
                        + "metricvalue is not null and "
                        + "metrictype not in ('downtime'," + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetrictypeNotUsedInChart") + ")) as f "
                        + "group by resourceid,service,metrictype ) as al "
                        + "left outer join "
                        + "(select distinct resourceid,host,resourcetype from "
                        + "servicemetrics "
                        + "where timestamp1 between " + smilli + " and " + emilli + " and "
                        + "metrictype in (" + metrictypeIn + ") and "
                        + "resourcetype='" + resourceType + "' and "
                        + "customerid=(select id from customerinfo where customername='" + cCustomer + "') and "
                        + "service='" + service + "') as hr "
                        + "using(resourceid) "
                        + "order by criticalsum) as fullservicetable "
                        + "group by host,service,resourcetype,resourceid order by metrictypehealth";
            }
            System.out.println("Report Metric Query /" + resourceType + "/ \n" + szQuery);

            log.debug("Report Metric Query /" + resourceType + "/ \n" + szQuery);
            ResultSet rs = ConnectionDAO.executerQuery(szQuery, customer);//stat.executeQuery(szQuery);

            while (rs.next()) {

                String metricvalues = "[]";
                String metricname = "[]";
                String slavalues = "[]";
                String metrictypehealth = "[]";

                String host = rs.getString("host");
                if (rs.getString("metricvalues") != null) {
                    metricvalues = "[" + rs.getString("metricvalues") + "]";
                }
                if (rs.getString("metricname") != null) {
                    String metricnameTemp = "\"" + rs.getString("metricname").replace(",", "\",\"") + "\"";
                    metricname = bizlogic.ChangeMetricNameAsPropertyname(metricnameTemp);
                }
                if (rs.getString("slavalues") != null) {
                    slavalues = "[" + rs.getString("slavalues") + "]";
                }
                if (rs.getString("metrictypehealth") != null) {
                    metrictypehealth = "[\"" + rs.getString("metrictypehealth").replace(",", "\",\"") + "\"]";
                }
                String serviceName = rs.getString("service");
                String resourcetype = rs.getString("resourcetype");
                String resourceId = rs.getString("resourceId");
                String resourceSubType = "";
                if (resourceType.equals("Desktop") || resourceType.equals("server")) {
                } else {
                    resourceSubType = rs.getString("resourceSubType");
                }


                if (serviceMetricInfo.containsKey(host + "," + resourceId)) {
                    serviceMetricInfo.remove(host + "," + resourceId);
                }
                if (!host.equals("null")) {
                    serviceMetricInfo.put(host + "," + resourceId, "\"ServiceName\":\"" + serviceName + "\",\"ResourceType\":\"" + resourcetype + "\",\"ServerName\":\"" + host + "\",\"ResourceNames\":" + metricname + ",\"ResourceValues\":" + metricvalues + ",\"SlaValues\":" + slavalues + ",\"Health\":" + metrictypehealth + ",\"ResourceSubType\":\"" + resourceSubType + "\",\"ResourceID\":\"" + resourceId + "\"");
                }
                host_resourcetype_list.add(host.trim() + "/" + resourcetype.trim());
            }

            /**
             * ***************************************************************************************************
             * Here we are setting All Host list Available in that Period
             * According to this we are showing Availability
             * ***************************************************************************************************
             */
            pojoObject.setHostListAvailable(host_resourcetype_list);
            ConnectionDAO.closeStatement();
            host_resourcetype_list = null;
        } catch (Exception e) {
            e.printStackTrace();
            log.error("DashBoard Report Metric Query /" + resourceType + "/ \n" + e.getMessage());
        }
        return serviceMetricInfo;
    }

    /**
     * ***************************************************************************************************
     * This method is giving default services with Health and Alert status for
     * Specified period and Generating JSON with this method
     * generateDefaultServiceResourcetypeJson()
     *
     * @param resourceType Different category as
     * Desktop,Server,DataBase,Network,JVM
     * @param startDate sub(endDate-timestampselection) in Date Format
     * @param endDate Current date in Date Format
     * @param timestampselection Selected Time Period
     * @param customer Selected customerID
     * @return szResourceTypeJson Json having service,health and Alert
     *
     * ***************************************************************************************************
     */
    public String generateServicesLeftGridJson(String cCustomer,
            String startDate, String endDate, String timestampselection,
            String customer) throws IOException, SQLException {
        String szServiceJson = "";
        try {
            serviceMetricInfo = new LinkedHashMap<String, String>();
            ticketInfo = new LinkedHashMap<String, String>();
            SimpleDateFormat formatter1 = new SimpleDateFormat(
                    "yyyy-MM-dd HH:mm:ss");
            Date dateStart = formatter1.parse(startDate);
            Date dateEnd = formatter1.parse(endDate);
            String date = formatter1.format(dateStart);
            String date1 = formatter1.format(dateEnd);
            long smilli = dateStart.getTime() / 1000;
            long emilli = dateEnd.getTime() / 1000;
            String szQueryMetric = "select dService.service as ServiceName, case when sum(health)>0 then 'CRITICAL' "
                    + "when sum(health)=0 then 'OK' else 'Default' end as  Health from "
                    + "(select distinct service from servicemetrics where resourcetype in (" + "\'"
                    + DBUtilHelper.getMetrics_mapping_properties().getProperty("ResourceName").replaceAll(",", "\',\'") + "\'"
                    + ") and service <> 'null' and customerid=(select id from customerinfo where customername='" + cCustomer
                    + "')) as dService left outer join (select service,CASE WHEN (metrictype in ("
                    + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger")
                    + ") and avg(metricvalue) < avg(sla)) or (metrictype not in ("
                    + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger")
                    + ") and avg(metricvalue) > avg(sla)) THEN 1 WHEN (metrictype not in ("
                    + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger")
                    + ") and avg(metricvalue) < avg(sla)) or (metrictype in ("
                    + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger")
                    + ") and avg(metricvalue) > avg(sla)) THEN 0 END as health from servicemetrics where service <> 'null' "
                    + "and timestamp1 between " + smilli + " and " + emilli + "  and metricvalue is not null and "
                    + "customerid=(select id from customerinfo where customername='" + cCustomer + "') and "
                    + "metrictype not in (" + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetrictypeNotUsedInChart")
                    + ") group by customerid,service,resourcetype,resourceid,metrictype) as hService using(service) group by ServiceName order by health";
//            Connection dataBaseConnectionMetric = ConnectionDAO.getConnection(customer);
            String[] headingNamesMetric = {"ServiceName", "Health"};
            serviceMetricInfo = generateJsonFromGivenQuery(szQueryMetric, headingNamesMetric, customer);
            serviceMetricInfo = modifyHashMap(serviceMetricInfo);
            log.debug("Default Service Metric Query /" + timestampselection + "/ \n" + szQueryMetric);

            String resTypes = DBUtilHelper.getMetrics_mapping_properties().getProperty("ResourceName");
            resTypes = "'" + resTypes.replaceAll(",", "','") + "'";
            log.info("resTypes==>>" + resTypes);
            //String szAvailJson = GetAvailability.getAvailabilityByPeriod(emilli, smilli, 
            //"'Desktop','server','DataBase','Network','JVM'", customer, timestampselection);
            //String szAvailJson = GetAvailability.getAvailabilityByPeriod(emilli, smilli, resTypes, cCustomer, null, customer, timestampselection);
            String szAvailJson = GetAvailability.getAvailabilityByPeriod(emilli, smilli, resTypes, customer, timestampselection,
                    cCustomer, null);
            JSONArray arrJobj = null;
            JSONObject temp = null;
            String tempKey = "";
            String chartType = "[\"0\",\"1\"]";
            String resourceId = "[\"Default\"]";
            try {
                arrJobj = new JSONArray(szAvailJson);
                for (int p = 0; p < arrJobj.length(); p++) {
                    temp = arrJobj.getJSONObject(p);
                    tempKey = temp.getString("ServiceName");
                    System.out.println("rekha  ServiceName==>>" + tempKey);
                    //if (!(tempKey.equals("null"))){
                    if (serviceMetricInfo.get(tempKey) == null || temp.getString("Health").equals("CRITICAL")) {
                        String availValue = "\"ServiceName\":\"" + temp.getString("ServiceName") + "\",\"Health\":\""
                                + temp.getString("Health") + "\",\"ResourceChartType\":" + chartType + ",\"ResourceNames\":"
                                + resourceId;
                        serviceMetricInfo.put(tempKey, availValue);
                    }
                    //}
                }
            } catch (Exception e) {
                e.printStackTrace();
            }


            String szQueryTicket = "select service as ServiceName,case when sum(summary)>0 then 'CRITICAL' when sum(summary)=0 "
                    + "then 'OK' else 'Default' end as Alert from  (select attributes4 as service,CASE WHEN substring"
                    + "(task_summary from position('[' in task_summary) for 25) like '%HSTDWN%' THEN 1 ELSE 0 END as summary "
                    + "from gatask where created_date between '" + date + "' and '" + date1 + "' and status!='Closed' and "
                    + "task_type!='SOX' and attributes4!='null' and customerid='" + cCustomer + "' group by summary,attributes4,attributes10) as dTicket "
                    + "group by ServiceName";
//            Connection dataBaseConnectionTicket = ConnectionDAO.getConnection(customer + "");
            String[] headingNamesTicket = {"ServiceName", "Alert"};
            ticketInfo = generateJsonFromGivenQuery(szQueryTicket, headingNamesTicket, customer);
            log.debug("Default Service Metric Query /" + timestampselection + "/ \n" + szQueryTicket);

            szServiceJson = bizlogic.generateDefaultServiceResourcetypeJson(serviceMetricInfo, ticketInfo);
//            dataBaseConnectionMetric = null;
//            dataBaseConnectionTicket = null;
            ticketInfo = null;
            serviceMetricInfo = null;
            formatter1 = null;
        } catch (Exception e) {
            e.printStackTrace();
            log.error("DashBoard Generate Default Service \n" + e.getMessage());
        }
        return szServiceJson;
    }

    public String generateCustomersLeftGridJson(String startDate, String endDate, String timestampselection,
            String customer) throws IOException, SQLException {
        String szServiceJson = "";
        try {
            serviceMetricInfo = new LinkedHashMap<String, String>();
            ticketInfo = new LinkedHashMap<String, String>();
            SimpleDateFormat formatter1 = new SimpleDateFormat(
                    "yyyy-MM-dd HH:mm:ss");
            Date dateStart = formatter1.parse(startDate);
            Date dateEnd = formatter1.parse(endDate);
            String date = formatter1.format(dateStart);
            String date1 = formatter1.format(dateEnd);
            long smilli = dateStart.getTime() / 1000;
            long emilli = dateEnd.getTime() / 1000;
            String szQueryMetric = "select dCustomer.customername as Customer, case when sum(health)>0 then 'CRITICAL' when sum(health)=0 "
                    + "then 'OK' else 'Default' end as  Health from (select customername from customerinfo where id in(select distinct customerid from servicemetrics where resourcetype in "
                    + "(" + "\'" + DBUtilHelper.getMetrics_mapping_properties().getProperty("ResourceName").replaceAll(",", "\',\'")
                    + "\'" + ") and customerid is not null)) as dCustomer left outer join (select customername,CASE WHEN (metrictype in ("
                    + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger") + ") and "
                    + "avg(metricvalue) < avg(sla)) or (metrictype not in ("
                    + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger") + ") and "
                    + "avg(metricvalue) > avg(sla)) THEN 1 WHEN (metrictype not in ("
                    + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger") + ") and "
                    + "avg(metricvalue) < avg(sla)) or (metrictype in ("
                    + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger") + ") and "
                    + "avg(metricvalue) > avg(sla)) THEN 0 END as health from customerinfo,servicemetrics where customerid is not null and "
                    + "timestamp1 between " + smilli + " and " + emilli + "  and metricvalue is not null and metrictype not in ("
                    + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetrictypeNotUsedInChart") + ") and customerid=id group by "
                    + "customername,service,resourcetype,resourceid,metrictype) as hCustomer using(customername) group by Customer order by health";
//            Connection dataBaseConnectionMetric = ConnectionDAO.getConnection(customer);
            String[] headingNamesMetric = {"Customer", "Health"};
            serviceMetricInfo = generateJsonFromGivenQuery(szQueryMetric, headingNamesMetric, customer);
            serviceMetricInfo = modifyHashMap(serviceMetricInfo);
            log.debug("Default Service Metric Query /" + timestampselection + "/ \n" + szQueryMetric);
            System.out.println("Query for customers left grid==>>" + szQueryMetric);

            String resTypes = DBUtilHelper.getMetrics_mapping_properties().getProperty("ResourceName");
            resTypes = "'" + resTypes.replaceAll(",", "','") + "'";
            log.info("resTypes==>>" + resTypes);
            //String szAvailJson = GetAvailability.getAvailabilityByPeriod(emilli, smilli, 
            //"'Desktop','server','DataBase','Network','JVM'", customer, timestampselection);
            //String szAvailJson = GetAvailability.getAvailabilityByPeriod(emilli, smilli, resTypes, null, null, customer, timestampselection);
            String szAvailJson = GetAvailability.getAvailabilityByPeriod(emilli, smilli, resTypes, customer, timestampselection, null,
                    null);
            JSONArray arrJobj = null;
            JSONObject temp = null;
            String tempKey = "";
            String chartType = "[\"0\",\"1\"]";
            String resourceId = "[\"Default\"]";
            try {
                arrJobj = new JSONArray(szAvailJson);
                for (int p = 0; p < arrJobj.length(); p++) {
                    temp = arrJobj.getJSONObject(p);
                    tempKey = temp.getString("Customer");
                    System.out.println("rekha  Customer==>>" + tempKey);
                    //if (!(tempKey.equals("null"))){
                    if (serviceMetricInfo.get(tempKey) == null || temp.getString("Health").equals("CRITICAL")) {
                        String availValue = "\"Customer\":\"" + temp.getString("Customer") + "\",\"Health\":\""
                                + temp.getString("Health") + "\",\"ResourceChartType\":" + chartType + ",\"ResourceNames\":"
                                + resourceId;
                        serviceMetricInfo.put(tempKey, availValue);
                    }
                    // }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }


            String szQueryTicket = "select customerid as Customer,case when sum(summary)>0 then 'CRITICAL' when sum(summary)=0 "
                    + "then 'OK' else 'Default' end as Alert from  (select customerid,CASE WHEN substring"
                    + "(task_summary from position('[' in task_summary) for 25) like '%HSTDWN%' THEN 1 ELSE 0 END as summary "
                    + "from gatask where created_date between '" + date + "' and '" + date1 + "' and status!='Closed' and "
                    + "task_type!='SOX' and attributes4!='null' and customerid!='null' group by customerid,summary,attributes10) as dTicket "
                    + "group by Customer";
//            Connection dataBaseConnectionTicket = ConnectionDAO.getConnection(customer + "");
            String[] headingNamesTicket = {"Customer", "Alert"};
            ticketInfo = generateJsonFromGivenQuery(szQueryTicket, headingNamesTicket, customer);
            log.debug("Default Customer Metric Query /" + timestampselection + "/ \n" + szQueryTicket);

            szServiceJson = bizlogic.generateDefaultServiceResourcetypeJson(serviceMetricInfo, ticketInfo);
//            dataBaseConnectionMetric = null;
//            dataBaseConnectionTicket = null;
            ticketInfo = null;
            serviceMetricInfo = null;
            formatter1 = null;
        } catch (Exception e) {
            e.printStackTrace();
            log.error("DashBoard Generate Default Service \n" + e.getMessage());
        }
        return szServiceJson;
    }

    /**
     * ***************************************************************************************************
     * This method is giving default Service ,ResourceType with Health and Alert
     * status for Specified period and Generating JSON with this method
     * generateDefaultServiceResourcetypeJson()
     *
     * @param resourceType Different category as
     * Desktop,Server,DataBase,Network,JVM
     * @param startDate sub(endDate-timestampselection) in Date Format
     * @param endDate Current date in Date Format
     * @param timestampselection Selected Time Period
     * @param customer Selected customerID
     * @return szResourceTypeJson Json having service,Resourcetype,health and
     * Alert
     *
     * ***************************************************************************************************
     */
    public String generateDefaultResourceTypeJson(String resourceType, String cCustomer, String service,
            String startDate, String endDate, String timestampselection,
            String customer) throws IOException, SQLException {
        String szResourceTypeJson = "";
        try {
            ticketInfo = new LinkedHashMap<String, String>();
            serviceMetricInfo = new LinkedHashMap<String, String>();
            SimpleDateFormat formatter1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            Date dateStart = formatter1.parse(startDate);
            Date dateEnd = formatter1.parse(endDate);
            String date = formatter1.format(dateStart);
            String date1 = formatter1.format(dateEnd);
            long smilli = dateStart.getTime() / 1000;
            long emilli = dateEnd.getTime() / 1000;
            //            Connection dataBaseConnectionMetric = ConnectionDAO.getConnection(customer);
            //            Connection dataBaseConnectionTicket = ConnectionDAO.getConnection(customer + "");
            ticketInfo.clear();
            serviceMetricInfo.clear();
            String szQueryMetric = "select dService.service as ServiceName, resourcetype as ResourceType ,case when sum(health)>0 "
                    + "then 'CRITICAL' when sum(health)=0 then 'OK' else 'Default' end as  Health from "
                    + "(select distinct service from servicemetrics where resourcetype in (" + "\'"
                    + DBUtilHelper.getMetrics_mapping_properties().getProperty("ResourceName").replaceAll(",", "\',\'") + "\'"
                    + ") and service='" + service + "' and service!=resourcetype) as dService left outer join (select service,resourcetype,CASE WHEN (metrictype in ("
                    + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger") + ") and "
                    + "avg(metricvalue) < avg(sla)) or (metrictype not in (" + DBUtilHelper.getMetrics_mapping_properties()
                    .getProperty("MetricTypeBelowThresholdIsDanger") + ") and avg(metricvalue) > avg(sla)) THEN 1 WHEN "
                    + "(metrictype not in (" + DBUtilHelper.getMetrics_mapping_properties().
                    getProperty("MetricTypeBelowThresholdIsDanger") + ") and avg(metricvalue) < avg(sla)) or (metrictype in ("
                    + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger") + ") and "
                    + "avg(metricvalue) > avg(sla)) THEN 0 END as health from servicemetrics where service='" + service
                    + "' and service!=resourcetype and timestamp1  between " + smilli + " and " + emilli + "  and metricvalue is not null and metrictype not in ("
                    + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetrictypeNotUsedInChart")
                    + ") and customerid=(select id from customerinfo where customername='" + cCustomer + "') and "
                    + "service='" + service + "' and service!=resourcetype "
                    + "group by service,resourcetype,metrictype) as hService using(service) group by ServiceName,ResourceType";
            String[] headingNamesMetric1 = {"ServiceName", "ResourceType", "Health"};
            log.debug("Default ResourceType Metric Query /" + timestampselection + "/ \n" + szQueryMetric);
            serviceMetricInfo = generateJsonFromGivenQuery(szQueryMetric, headingNamesMetric1, customer);
            serviceMetricInfo = modifyHashMap(serviceMetricInfo);

            String resTypes = DBUtilHelper.getMetrics_mapping_properties().getProperty("ResourceName");
            resTypes = "'" + resTypes.replaceAll(",", "','") + "'";
            //String szAvailJson = GetAvailability.getAvailabilityByPeriod(emilli, smilli, 
            //"'Desktop','server','DataBase','Network','JVM'", customer, timestampselection);
            log.info("resTypes==>>" + resTypes);
            //String szAvailJson = GetAvailability.getAvailabilityByPeriod(emilli, smilli, resTypes, cCustomer, service, customer, timestampselection);
            String szAvailJson = GetAvailability.getAvailabilityByPeriod(emilli, smilli, resTypes, customer, timestampselection, cCustomer,
                    service);
            JSONArray arrJobj = null;
            JSONObject temp = null;
            String tempKey = "";
            try {
                arrJobj = new JSONArray(szAvailJson);
                for (int p = 0; p < arrJobj.length(); p++) {
                    temp = arrJobj.getJSONObject(p);
                    tempKey = temp.getString("ServiceName") + "," + temp.getString("ResourceType");
                    if (serviceMetricInfo.get(tempKey) == null || temp.getString("Health").equals("CRITICAL")) {
                        serviceMetricInfo.remove(temp.getString("ServiceName") + ",null");
                        String availValue = "\"ServiceName\":\"" + temp.getString("ServiceName") + "\",\"ResourceType\":\"" + temp.getString("ResourceType") + "\",\"Health\":\"" + temp.getString("Health") + "\"";
                        serviceMetricInfo.put(tempKey, availValue);
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }

            String szQueryTicket = "select service as ServiceName,ResourceType,case when sum(summary)>0 then 'CRITICAL' when "
                    + "sum(summary)=0 then 'OK' else 'Default' end as Alert from  (select attributes4 as service,attributes10 "
                    + "as ResourceType,CASE WHEN substring(task_summary from position('[' in task_summary) for 25) like '%HSTDWN%' "
                    + "THEN 1 ELSE 0 END as summary from gatask where created_date between '" + date + "' and '" + date1
                    + "' and status!='Closed' and task_type!='SOX' and attributes4!='null' and attributes4='" + service + "' group by summary,attributes4,attributes10) "
                    + "as dTicket group by ServiceName,ResourceType";

            String[] headingNamesTicket1 = {"ServiceName", "ResourceType", "Alert"};
            log.debug("Default ResourceType Ticket Query /" + timestampselection + "/ \n" + szQueryTicket);

            ticketInfo = generateJsonFromGivenQuery(szQueryTicket, headingNamesTicket1, customer);

            szResourceTypeJson = bizlogic.generateDefaultServiceResourcetypeJson(serviceMetricInfo, ticketInfo);
            //            dataBaseConnectionMetric = null;
            //            dataBaseConnectionTicket = null;
            ticketInfo = null;
            serviceMetricInfo = null;
            formatter1 = null;
        } catch (Exception e) {
            e.printStackTrace();
            log.error("DashBoard Generate DefaultResourceType \n" + e.getMessage());
        }
        System.out.println("Returning defaultResourceType.json==>>" + szResourceTypeJson);
        return szResourceTypeJson;
    }

    /**
     * ***************************************************************************************************
     * Here we are Executing both Ticket and Metric Query one by one because
     * both having different dataBase Connection and sending as LinkedHashMap
     *
     * @param szQueryString Query to be Executed
     * @param headingNames Name of Columns in Executed Query
     * @param dataBaseConnection Specific query specific Connection
     * @return szMetricTypemap return LinkedHashMap
     * ***************************************************************************************************
     */
    public LinkedHashMap<String, String> generateJsonFromGivenQuery(String szQueryString, String[] headingNames, String customer) {
        LinkedHashMap<String, String> szMetricTypemap = new LinkedHashMap<String, String>();

        try {
//            Statement stat2 = dataBaseConnection.createStatement();
            String szMetricTypeValueJson = "";
            ResultSet rs4 = ConnectionDAO.executerQuery(szQueryString, customer);//stat2.executeQuery(szQueryString);
            while (rs4.next()) {
                String szConcatColumn = "";
                szMetricTypeValueJson = "";
                for (int i = 0; i < headingNames.length - 1; i++) {
                    System.out.println("headingNames[i]==>>" + headingNames[i]);
                    if (!headingNames[headingNames.length - 1].equals("Alert")) {
                        System.out.println("rs4.getString(headingNames[i])==>>" + rs4.getString(headingNames[i]));
                        if (rs4.getString(headingNames[i]) != null) {
                            szConcatColumn = szConcatColumn + ",\"" + headingNames[i] + "\":\"" + rs4.getString(headingNames[i]) + "\"";
                        }
                    }
                    szMetricTypeValueJson = szMetricTypeValueJson + "," + rs4.getString(headingNames[i]);
                }
                szConcatColumn = szConcatColumn + ",\"" + headingNames[headingNames.length - 1] + "\":\"" + rs4.getString(headingNames[headingNames.length - 1]) + "\"";
                szMetricTypemap.put(szMetricTypeValueJson.substring(1), szConcatColumn.substring(1));
            }
            ConnectionDAO.closeStatement();
        } catch (Exception e) {
            e.printStackTrace();
            log.error("Error in generateJsonFromGivenQuery" + e.getMessage());
        }
        return szMetricTypemap;
    }

    public LinkedHashMap<String, String> collectTicketdata1(String customer, String resourceType, String cCustomer, String service, String date, String date1) throws IOException, SQLException {
        ticketInfo = new LinkedHashMap<String, String>();
        try {
//            uniqueconnection = ConnectionDAO.getConnection(customer + "");
//            stat = uniqueconnection.createStatement();

            String szQuery = "select host,resourcetype,ServiceName,resourceID,case when sum(criticalcheck)>0 "
                    + "then 'CRITICAL' else 'OK' end as health from (select attributes6 as host,attributes10 "
                    + "as resourcetype,attributes4 as ServiceName,attributes12 as resourceID,CASE WHEN "
                    + "substring(task_summary from position('[' in task_summary) for 25) like '%HSTDWN%' THEN 1"
                    + " ELSE 0 END as criticalcheck from gatask where created_date between  '" + date
                    + "' and '" + date1 + "' and status!='Closed' and task_type!='SOX' and attributes10='"
                    + resourceType + "' and attributes4='" + service + "' group by attributes4,attributes12,attributes6,attributes10,"
                    + "criticalcheck) as alert group by host,resourcetype,ServiceName,resourceID";
            /**
             * ***************************************************************************************************
             * This Query will give Modified result from all necessary tables
             * like gatasktypeassignee, gatask table .. here concatenating the
             * result came from GAtask for Summary Count and checking hostdown
             * status array_agg function in postgresql below 8 version we have
             * to create by following command: create aggregate array_agg (
             * sfunc = array_append, basetype = anyelement, stype = anyarray,
             * initcond = '{}' );
             * ***************************************************************************************************
             */
            log.debug("Ticket Query /" + resourceType + "/\n" + szQuery);

            ResultSet rs = ConnectionDAO.executerQuery(szQuery, customer);//stat.executeQuery(szQuery);

            while (rs.next()) {
                String serviceName = rs.getString("ServiceName");
                resourceType = rs.getString("resourcetype");
                String host = rs.getString("host");
                String resourceID = rs.getString("resourceID");
                String health = rs.getString("health");


                /**
                 * Generating Map for Chart Generation
                 */
                ticketInfo.put(serviceName + "," + host + "," + resourceID, "\"hstdwnstatus\":[\"" + health + "\"]");
            }
            ConnectionDAO.closeStatement();
        } catch (Exception e) {
            e.printStackTrace();
            log.error("DashBoard Ticket Query /" + resourceType + "/\n" + e.getMessage());
        } finally {
        }
        return ticketInfo;
    }

    /**
     * ************************************************************************************************
     * This method is giving All metricType,Avg(Metricvalues) related to each
     * metricType, SLAValues related to each
     * metricType,services,ResourceType,ResourceId,Servername
     *
     * @param customer Selected customerID
     * @param resourceType Different category as
     * Desktop,Server,DataBase,Network,JVM
     * @param smilli date in second as long Timestamp(Current Time-selected Time
     * Period)
     * @param emilli date in second as long Timestamp(Current Time)
     * @return serviceMetricInfo Metric information as string Json
     *
     * *************************************************************************************************
     */
    public LinkedHashMap<String, String> collectMetricdata1(String customer, String resourceType, String cCustomer, String service,
            long smilli, long emilli) throws IOException, SQLException {
        try {
            serviceMetricInfo = new LinkedHashMap<String, String>();

            /**
             * *************************************************************************************************
             * Here we are checking the condition of showing critical according
             * to avg (means avg of actual value compare with avg of actual sla)
             * or Count (means actual value compare with actual sla)
             * *************************************************************************************************
             *
             */
            String metricHealthCheckLogic = "case when sum(criticalflag)>0 then 'CRITICAL' else 'OK' end";
            if (DBUtilHelper.getMetrics_mapping_properties().getProperty("HealthCheck").equals("AVG")) {
                metricHealthCheckLogic = "case when (avg(metricvalue)>avg(sla) and metrictype not in ("
                        + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger")
                        + ")) or (avg(metricvalue)<avg(sla) and metrictype in ("
                        + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger")
                        + ")) then  'CRITICAL' else 'OK' end";
            }

            String szQuery = "select host,service,resourcetype,resourceid,array_to_string(array_agg(metrictype),',') as metricname,array_to_string(array_agg(criticalsum),',') as metrictypehealth,case when resourceSubType is null then resourcetype else resourceSubType end as resourceSubType from "
                    + "( select def.resourcesubtype as resourceSubType,def.host,def.service as service,def.resourcetype,def.resourceid as resourceid,case when metrictype is null then 'default' else metrictype end as metrictype,case when criticalsum is null then 'GREY' else criticalsum end as criticalsum from "
                    + "( select host,resourcetype,resourceid,case when metrictype in (" + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetrictypeCountAsValue") + ") then count(metrictype) else   round(cast(avg(metricvalue) as numeric),2) end as metricvalue,metrictype,round(cast(avg(sla) as numeric),2) as sla, " + metricHealthCheckLogic + " as criticalsum from "
                    + "( select host,resourcetype,resourceid, metricvalue,metrictype,sla,case when metricvalue>sla and metrictype not in (" + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger") + ") or metricvalue<sla and metrictype  in (" + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger") + ") then 1 else 0  end as criticalflag from "
                    + "  servicemetrics "
                    + "where timestamp1 between " + smilli + " and " + emilli + " and  "
                    + "resourcetype='" + resourceType + "' and "
                    + "customerid=(select id from customerinfo where customername='" + cCustomer + "') and "
                    + "service='" + service + "' and "
                    + "metricvalue is not null and "
                    + "metrictype not in ('downtime'," + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetrictypeNotUsedInChart") + ")) as f "
                    + "group by host,resourcetype,resourceid,metrictype "
                    + "order by criticalsum) as f1 "
                    + "right outer join "
                    + "(select distinct host,resourceid,service,resourcetype,resourcesubtype from "
                    + "hostinfo "
                    + "where resourcetype='" + resourceType + "' and "
                    + "customerid=(select id from customerinfo where customername='" + cCustomer + "') and "
                    + "service='" + service + "' and "
                    + "service <>'null') as def using(host,resourceid)) as s1 "
                    + "group by host,service,resourcetype,resourceid,resourcesubtype order by metrictypehealth";


            /*if (resourceType.equals("Desktop") || resourceType.equals("server")) {
             szQuery = "select host,service,resourcetype,resourceid,array_to_string(array_agg(metrictype),',') as metricname,array_to_string(array_agg(criticalsum),',') as metrictypehealth from "
             + "( select host,resourcetype, hr.service,hr.resourceid as resourceid,case when metrictype is null then 'default' else metrictype end as metrictype,case when criticalsum is null then 'GREY' else criticalsum end as criticalsum from "
             + "( select host,resourceid,case when metrictype in (" + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetrictypeCountAsValue") + ") then count(metrictype) else   round(cast(avg(metricvalue) as numeric),2) end as metricvalue,metrictype,round(cast(avg(sla) as numeric),2) as sla, " + metricHealthCheckLogic + " as criticalsum from "
             + "( select host,resourceid, metricvalue,metrictype,sla,case when metricvalue>sla and metrictype not in (" + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger") + ") or metricvalue<sla and metrictype in (" + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetricTypeBelowThresholdIsDanger") + ") then 1 else 0  end as criticalflag from "
             + "servicemetrics "
             + "where timestamp1 between " + smilli + " and " + emilli + " and  "
             + "resourcetype='" + resourceType + "' and "
             + "customerid=(select id from customerinfo where customername='" + cCustomer + "') and "
             + "service='" + service + "' and "
             + "metricvalue is not null and "
             + "metrictype not in ('downtime'," + DBUtilHelper.getMetrics_mapping_properties().getProperty("MetrictypeNotUsedInChart") + ")) as f "
             + "group by host,resourceid,metrictype ) as al "
             + "right outer join "
             + "(select distinct resourceid,host,service,resourcetype from "
             + "hostinfo "
             + "where resourcetype='" + resourceType + "' and "
             + "customerid=(select id from customerinfo where customername='" + cCustomer + "') and "
             + "service='" + service + "' ) as hr "
             + "using(host,resourceid) "
             + "order by criticalsum) as fullservicetable "
             + "group by host,service,resourcetype,resourceid order by metrictypehealth";
             }*/
//            uniqueconnection = ConnectionDAO.getConnection(customer);
//            stat = uniqueconnection.createStatement();

            /**
             * ***************************************************************************************************
             * Here Query is Separated according to resource type because server
             * and Desktop taking more time because of more data , We can use
             * the same query by removing if condition array_agg function in
             * postgresql below 8 version we have to create by following
             * command: create aggregate array_agg ( sfunc = array_append,
             * basetype = anyelement, stype = anyarray, initcond = '{}' );
             * ***************************************************************************************************
             *
             */
            log.debug("Report Metric Query /" + resourceType + "/ \n" + szQuery);
            ResultSet rs = ConnectionDAO.executerQuery(szQuery, customer);//stat.executeQuery(szQuery);

            while (rs.next()) {
                String metricname = "[]";
                String chartType = "[\"0\",\"1\"]";
                String metrictypehealth = "[]";

                String host = rs.getString("host");
                if (rs.getString("metrictypehealth") != null) {
                    metrictypehealth = "[\"" + rs.getString("metrictypehealth").replace(",", "\",\"") + "\"]";
                }
                if (rs.getString("metricname") != null) {
                    String metricnameTemp = "\"" + rs.getString("metricname").replace(",", "\",\"") + "\"";
                    metricname = bizlogic.ChangeMetricNameAsPropertyname(metricnameTemp);
                    if (!metricnameTemp.equals("Default")) {
                        chartType = bizlogic.getChartType(resourceType, metricnameTemp, metrictypehealth);
                    }
                }

                String serviceName = rs.getString("service");
                String resourcetype = rs.getString("resourcetype");
                String resourceId = rs.getString("resourceId");
                String resourceSubType = "resourceSubType";
                /*if (resourceType.equals("Desktop") || resourceType.equals("server")) {
                 } else {*/
                resourceSubType = rs.getString("resourceSubType");
                //}


                if (serviceMetricInfo.containsKey(serviceName + "," + host + "," + resourceId)) {
                    serviceMetricInfo.remove(serviceName + "," + host + "," + resourceId);
                }
                if (!host.equals("null")) {
                    serviceMetricInfo.put(serviceName + "," + host + "," + resourceId, "\"ServiceName\":\"" + serviceName
                            + "\",\"ResourceType\":\"" + resourceType + "\",\"ServerName\":\"" + host + "\",\"ResourceNames\":"
                            + metricname + ",\"Health\":" + metrictypehealth + ",\"ResourceSubType\":\"" + resourceSubType
                            + "\",\"ResourceChartType\":" + chartType + ",\"ResourceID\":\"" + resourceId + "\"");
                }

            }
            System.out.println("QueryExecutor.collectMetricdata1()    serviceMetricInfo = " + serviceMetricInfo);

            /**
             * ***************************************************************************************************
             * Here we are setting All Host list Available in that Period
             * According to this we are showing Availability
             * ***************************************************************************************************
             */
            ConnectionDAO.closeStatement();
        } catch (Exception e) {
            e.printStackTrace();
            log.error("DashBoard Report Metric Query /" + resourceType + "/ \n" + e.getMessage());
        }

        return serviceMetricInfo;
    }

    public String getWatchDogAlertJson(String customer, String cCustomer) {
        String watchDogQuery = "select host,metrictype,"
                + "to_char(to_timestamp(max(timestamp1)), 'yyyy/MM/dd HH24:mi:SS') as TimeStamps,"
                + "resourcetype from servicemetrics where metrictype in ("
                + DBUtilHelper.getMetrics_mapping_properties().getProperty("WatchDogMetricList")
                + ") and customerid=(select id from customerinfo where customername='" + cCustomer + "') "
                + "group by metrictype,resourcetype,host";
        System.out.println("WatchDog Query:====" + watchDogQuery);
        String watchdogJson = "[";
        try {
            Connection uniqueconnection = ConnectionDAO.getConnection(customer);
            Statement stat2 = uniqueconnection.createStatement();

            String szMetricTypeValueJson = "";
            ResultSet rs4 = stat2.executeQuery(watchDogQuery);
            if (rs4 == null) {
                System.out.println("822 rs4 null;");
            } else {
                System.out.println("822 rs4 is not null;");
            }
            String resourceType = "";
            String metrictype = "";
            String timestamp = "";
            String serverName = "";
            while (rs4.next()) {
                serverName = rs4.getString("host");
                resourceType = rs4.getString("resourcetype");
                metrictype = rs4.getString("metrictype");
                timestamp = rs4.getString("TimeStamps");
                szMetricTypeValueJson = szMetricTypeValueJson + ",{\"ServerName\":\"" + serverName + "\",\"ResourceType\":\"" + resourceType + "\",\"MetricType\":\"" + metrictype + "\",\"Timestamps\":\"" + timestamp + "\"}";
            }
            if (szMetricTypeValueJson.equals("")) {
                watchdogJson = "[]";
            } else {
                watchdogJson = watchdogJson + szMetricTypeValueJson.substring(1) + "]";
            }
            try {
                rs4.close();
            } catch (Exception ex) {
                ex.printStackTrace();
            }
            try {
                stat2.close();
            } catch (Exception ex) {
                ex.printStackTrace();
            }
            rs4 = null;
            stat2 = null;
        } catch (Exception e) {
            e.printStackTrace();
            log.error("DashBoard Generate Default Service and ResourceType \n" + e.getMessage());
        }
        return watchdogJson;
    }

    public String getMetricResourceTypeMapping(String customer, String cCustomer, String service) {
        String MetricResourceTypeMappingJson = "";
        String szQuery = "select distinct metrictype,resourcetype from smetricslathresholds where "
                + "customerid=(select id from customerinfo where customername='" + cCustomer + "' and service='" + service + "') order by resourcetype,metrictype ";

        try {
//            uniqueconnection = ConnectionDAO.getConnection(customer);
//            Statement stat2 = uniqueconnection.createStatement();

            String propertyMetricName1 = "";
            String resourceType1 = "";
            String propertyMetricName2 = "";
            String resourceType2 = "";
            String propertyMetricName3 = "";
            String resourceType3 = "";
            String propertyMetricName4 = "";
            String resourceType4 = "";
            String propertyMetricName5 = "";
            String resourceType5 = "";
            ResultSet rs4 = ConnectionDAO.executerQuery(szQuery, customer);//stat2.executeQuery(szQuery);
            while (rs4.next()) {
                String resourceType = rs4.getString("resourcetype");
                if (resourceType.equals("Desktop")) {
                    propertyMetricName1 = propertyMetricName1 + ",\"" + DBUtilHelper.getMetrics_mapping_properties().getProperty(rs4.getString("metrictype")) + "\"";
                    resourceType1 = resourceType;
                } else if (resourceType.equals("server")) {
                    propertyMetricName2 = propertyMetricName2 + ",\"" + DBUtilHelper.getMetrics_mapping_properties().getProperty(rs4.getString("metrictype")) + "\"";
                    resourceType2 = resourceType;
                } else if (resourceType.equals("DataBase")) {
                    propertyMetricName3 = propertyMetricName3 + ",\"" + DBUtilHelper.getMetrics_mapping_properties().getProperty(rs4.getString("metrictype")) + "\"";
                    resourceType3 = resourceType;
                } else if (resourceType.equals("Network")) {
                    propertyMetricName4 = propertyMetricName4 + ",\"" + DBUtilHelper.getMetrics_mapping_properties().getProperty(rs4.getString("metrictype")) + "\"";
                    resourceType4 = resourceType;
                } else if (resourceType.equals("JVM")) {
                    propertyMetricName5 = propertyMetricName5 + ",\"" + DBUtilHelper.getMetrics_mapping_properties().getProperty(rs4.getString("metrictype")) + "\"";
                    resourceType5 = resourceType;
                }

            }
            if (!propertyMetricName1.equals("")) {
                propertyMetricName1 = propertyMetricName1.substring(1);
            }
            if (!propertyMetricName2.equals("")) {
                propertyMetricName2 = propertyMetricName2.substring(1);
            }
            if (!propertyMetricName3.equals("")) {
                propertyMetricName3 = propertyMetricName3.substring(1);
            }
            if (!propertyMetricName4.equals("")) {
                propertyMetricName4 = propertyMetricName4.substring(1);
            }
            if (!propertyMetricName5.equals("")) {
                propertyMetricName5 = propertyMetricName5.substring(1);
            }

            MetricResourceTypeMappingJson = "[{"
                    + "\"ResourceType\":\"" + resourceType1 + "\","
                    + "\"ResourceNames\":[" + propertyMetricName1 + "]"
                    + "},{"
                    + "\"ResourceType\":\"" + resourceType2 + "\","
                    + "\"ResourceNames\":[" + propertyMetricName2 + "]"
                    + "},{"
                    + "\"ResourceType\":\"" + resourceType3 + "\","
                    + "\"ResourceNames\":[" + propertyMetricName3 + "]"
                    + "},{"
                    + "\"ResourceType\":\"" + resourceType4 + "\","
                    + "\"ResourceNames\":[" + propertyMetricName4 + "]"
                    + "},{"
                    + "\"ResourceType\":\"" + resourceType5 + "\","
                    + "\"ResourceNames\":[" + propertyMetricName5 + "]"
                    + "}]";
            ConnectionDAO.closeStatement();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return MetricResourceTypeMappingJson;
    }

    public String generatePerformanceJsons(String szResourceType, String cCustomer, String service, String resType, String metricType,
            String configuredMetricType, String jsonGenerator, String startDate, String endDate, String timestampselection,
            String customer) {
        String perfJSON = "";
        try {
            SimpleDateFormat formatter1 = new SimpleDateFormat(
                    "yyyy-MM-dd HH:mm:ss");
            Date dateStart = formatter1.parse(startDate);
            Date dateEnd = formatter1.parse(endDate);
            long smilli = dateStart.getTime() / 1000;
            long emilli = dateEnd.getTime() / 1000;
            log.debug("In qe.generatePerformanceJsons==>>smilli:" + smilli + "::emilli:" + emilli);
            Class generatorCls = Class.forName(jsonGenerator);
            Object generatorObj = generatorCls.newInstance();
            Class[] inputArr = new Class[]{String.class, String.class, String.class, String.class, String.class, String.class, Long.TYPE,
                Long.TYPE, String.class, String.class};
            Method generatorMthd = generatorCls.getDeclaredMethod("generateJSON", inputArr);
            perfJSON = (String) generatorMthd.invoke(generatorObj, szResourceType, cCustomer, service, resType, metricType, configuredMetricType,
                    smilli, emilli, timestampselection, customer);
            return perfJSON;
        } catch (Exception e) {
            log.error("Error in generateServicePerformanceJson()==>>" + e.toString());
            e.printStackTrace();
        }
        return null;
    }

    public static ArrayList getCCustomers(String customer) {
        String szQuery = "select customername from customerinfo";
        ArrayList cCustomers = new ArrayList();
        ResultSet rs;
        try {
            rs = ConnectionDAO.executerQuery(szQuery, customer);
            while (rs.next()) {
                cCustomers.add(rs.getString(1));
            }
            return cCustomers;
        } catch (Exception e) {
            log.error("Error in getCCustomers==>>" + e.toString());
            e.printStackTrace();
        } finally {
            rs = null;
        }
        return null;
    }

    public static ArrayList getServiceList(String customer, String cCustomer) {
        String szQuery = "select distinct service from hostinfo where customerid=(select id from customerinfo "
                + "where customername='" + cCustomer + "')";
        ArrayList serviceLst = new ArrayList();
        ResultSet rs;
        try {
            rs = ConnectionDAO.executerQuery(szQuery, customer);
            while (rs.next()) {
                serviceLst.add(rs.getString(1));
            }
            return serviceLst;
        } catch (Exception e) {
            log.error("Error in getServiceList==>>" + e.toString());
            e.printStackTrace();
        }
        return null;
    }

    public LinkedHashMap<String, String> collectTicketDataForCustomer(String customer, String cCustomer, String date, String date1,
            String selection) throws IOException, SQLException {
        ticketInfo = new LinkedHashMap<String, String>();
        try {
//            uniqueconnection = ConnectionDAO.getConnection(customer + "");
//            stat = uniqueconnection.createStatement();

            String szQuery = "";

            if (selection.equals("CriticalAlerts")) {
                szQuery = "select array_to_string(array_agg(summaryname),',') as ResourceNames,"
                        + "array_to_string(array_agg(summarycount),',') as ResourceValues,case when sum(criticalcheck)>0 "
                        + "then 'CRITICAL' else 'OK' end as Health from (select count(*) as summarycount,"
                        + "substring(task_summary from position('[' in task_summary) for 25) as summaryname, CASE WHEN "
                        + "substring(task_summary from position('[' in task_summary) for 25) like '%HSTDWN%' "
                        + "THEN 1 ELSE 0 END as criticalcheck from gatask where created_date between  '" + date + "' and '" + date1
                        + "' and status!='Closed' and task_type!='SOX' and customerid='" + cCustomer
                        + "' group by summaryname) as cAlert";
            } else if (selection.equals("AlertsByAssignee")) {
                szQuery = "select array_to_string(array_agg(assigneenames),',') as ResourceNames,"
                        + "array_to_string(array_agg(ticketcount),',') as ResourceValues,case when sum(ticketcount)>0 then 'CRITICAL' else 'OK' "
                        + "end as Health from (select count(*)as ticketcount,g1.assignee as assigneenames "
                        + "from gatask g2 ,gatasktypeassignee g1 where created_date between  '" + date + "' and '" + date1
                        + "' and g1.taskid=g2.task_id and action_assignee=1 and customerid='" + cCustomer
                        + "' group by g1.assignee) as assig";
            } else if (selection.equals("AlertsByStatus")) {
                szQuery = "select array_to_string(array_agg(statusnames),',') as ResourceNames,"
                        + "array_to_string(array_agg(statuscount),',') as ResourceValues,case when sum(statuscount)>0 then 'CRITICAL' else 'OK' "
                        + "end as Health from (select count(*) as statuscount,status as statusnames "
                        + "from gatask where created_date between  '" + date + "' and '" + date1
                        + "' and customerid='" + cCustomer + "' group by status) as sAlert";
            }

            /**
             * ***************************************************************************************************
             * This Query will give Modified result from all necessary tables
             * like gatasktypeassignee, gatask table .. here concatenating the
             * result came from GAtask for Summary Count and checking hostdown
             * status array_agg function in postgresql below 8 version we have
             * to create by following command: create aggregate array_agg (
             * sfunc = array_append, basetype = anyelement, stype = anyarray,
             * initcond = '{}' );
             * ***************************************************************************************************
             */
            System.out.println("Ticket Query /" + cCustomer + "/\n" + szQuery);
            log.debug("Ticket Query /" + cCustomer + "/\n" + szQuery);

            ResultSet rs = ConnectionDAO.executerQuery(szQuery, customer);//stat.executeQuery(szQuery);

            while (rs.next()) {
                String alertCount = "[]";
                String alertName = "";
                String alertHealth = "[]";
                String nameOfAlert = "";
                //String serviceName = rs.getString("ServiceName");

                /**
                 * ************************************************************************************************
                 * Default Assignee that having no Ticket Assigned for specific
                 * host
                 * ************************************************************************************************
                 *
                 */
                String sz_query_assignee_list = "select distinct(user_id) as status from gaoperator where user_id !='Admin' "
                        + "and user_id!='None' and  user_id not in (select g1.assignee from gatask g2 ,"
                        + "gatasktypeassignee g1 where  created_date between '" + date + "' and '" + date1 + "'  and "
                        + "g1.taskid=g2.task_id and action_assignee=1 and customerid='" + cCustomer + "') order by user_id";
                String assigneeList = getDefaultAssigneeStatus(sz_query_assignee_list, customer);

                /**
                 * Default Status for specific host
                 */
                String sz_query_status_list = " select distinct(status) as status from gastatus where status not in "
                        + "(select status from gatask where created_date between '" + date + "' and '" + date1
                        + "'  and customerid='" + cCustomer + "') order by status";
                String statusList = getDefaultAssigneeStatus(sz_query_status_list, customer);

                if (rs.getString("ResourceValues") != null) {
                    alertCount = "[" + rs.getString("ResourceValues") + "]";
                }
                if (rs.getString("ResourceNames") != null) {
                    alertName = "\'" + rs.getString("ResourceNames").replace(",", "\',\'") + "\'";
                }
                if (rs.getString("Health") != null) {
                    alertHealth = "[\"" + rs.getString("Health") + "\"]";
                }

                if (selection.equals("AlertsByAssignee")) {
                    if (alertName.equals("")) {
                        nameOfAlert = "[" + assigneeList.substring(1) + "]";
                    } else {
                        //nameOfAlert = "[" + alertName + assigneeList + "]";
                        String tmpName = alertName.replaceAll("\'", "\"");
                        nameOfAlert = "[" + tmpName + assigneeList + "]";
                    }

                } else if (selection.equals("AlertsByStatus")) {
                    if (alertName.equals("")) {
                        nameOfAlert = "[" + statusList.substring(1) + "]";
                    } else {
                        //nameOfAlert = "[" + alertName + statusList + "]";
                        String tmpName = alertName.replaceAll("\'", "\"");
                        nameOfAlert = "[" + tmpName + statusList + "]";
                    }

                }
                String summaryname1 = "";
                String summarynameconcat = "";

                /**
                 * **************************************************************************************************
                 * Default Task Summary accepted from properties: File name is
                 * TaskSummay.Properties For specific resourceType and Checking
                 * Task-Summary is present or not. if present then changing from
                 * the properties(MetricMapping.prperties) file
                 * **************************************************************************************************
                 */
                if (selection.equals("CriticalAlerts")) {

                    String[] splitsummaryname = alertName.split(",");
                    if (splitsummaryname.length > 0 && !splitsummaryname[0].equalsIgnoreCase("")) {
                        for (int b = 0; b < splitsummaryname.length; b++) {
                            System.out.println("splitsummaryname==>>" + splitsummaryname[b]);
                            /*if (resourceType.equals("server")) {
                             if (!splitsummaryname[b].toLowerCase().contains("fnsp") && !splitsummaryname[b].toLowerCase().contains("tem")) {
                             //System.out.println("183>>>>splitsummaryname[b] = " + splitsummaryname[b] + ", DBUtilHelper.getMetrics_mapping_properties().getProperty(splitsummaryname[b]) = " + DBUtilHelper.getMetrics_mapping_properties().getProperty(splitsummaryname[b]).trim());
                             summarynameconcat = summarynameconcat + ",\"" + DBUtilHelper.getMetrics_mapping_properties().getProperty(splitsummaryname[b]).trim() + "\"";
                             }
                             } else {*/
                            summarynameconcat = summarynameconcat + ",\"" + DBUtilHelper.getMetrics_mapping_properties().getProperty(splitsummaryname[b]).trim() + "\"";
                            //}
                        }

                        summarynameconcat = summarynameconcat.substring(1);
                        summaryname1 = summarynameconcat;
                    }

                    /**
                     * **************************************************************************************************
                     * Changing Task-Summary Name Present in
                     * Properties(TaskSummary.properties) with some useful
                     * meaning from other properties(MetricMapping.properties)
                     * files
                     * **************************************************************************************************
                     *
                     */
                    /*String[] szArrayCriticalNames = DBUtilHelper.getProperties().getProperty(resourceType).split(",");
                     for (int c = 0; c < szArrayCriticalNames.length; c++) {
                     if (!summaryname1.contains(DBUtilHelper.getMetrics_mapping_properties().getProperty(szArrayCriticalNames[c]).trim())) {
                     summaryname1 = summaryname1 + ",\"" + DBUtilHelper.getMetrics_mapping_properties().getProperty(szArrayCriticalNames[c]).trim() + "\"";
                     }
                     }*/
                }
                if (selection.equals("CriticalAlerts")) {
                    nameOfAlert = "[" + summaryname1 + "]";
                }

                /**
                 * Generating Map for Chart Generation
                 */
                //ticketInfo.put(serviceName, "\"ServiceName\":\"" + serviceName + "\",\"ResourceNames\":" + nameOfAlert
                ticketInfo.put(cCustomer, "\"ServiceName\":\"" + cCustomer + "\",\"ResourceNames\":" + nameOfAlert
                        + ",\"ResourceValues\":" + alertCount + ",\"SlaValues\":[10000],\"Health\":" + alertHealth);
                //ticketInfo.put(host+","+resourceId,"\"ServerName\":\""+host+"\",\"ServiceName\":\""+serviceName+"\",\"ResourceID\":\""+resourceId+"\",\"ResourceType\":\""+resourceType+"\",\"summarycount\":"+summarycount+",\"summaryname\":"+criticalSummaryName+",\"hstdwnstatus\":"+hstdwnstatus+",\"ticketcount\":"+ticketcount+",\"assigneenames\":"+assigneenames+",\"statusnames\":"+statusnames+",\"statuscount\":"+statuscount);
            }
            ConnectionDAO.closeStatement();

            if (ticketInfo.isEmpty()) {
                ticketInfo.put("DefaultMapValue", "\"summarycount\":[],\"summaryname\":[],\"hstdwnstatus\":[],\"ticketcount\":[],\"assigneenames\":[],\"statusnames\":[],\"statuscount\":[]");
            }
        } catch (Exception e) {
            e.printStackTrace();
            log.error("DashBoard Ticket Query /" + cCustomer + "/\n" + e.getMessage());
        } finally {
        }
        return ticketInfo;
    }

    public LinkedHashMap<String, String> collectTicketDataForService(String customer, String cCustomer, String service, String date,
            String date1, String selection) throws IOException, SQLException {
        ticketInfo = new LinkedHashMap<String, String>();
        try {
//            uniqueconnection = ConnectionDAO.getConnection(customer + "");
//            stat = uniqueconnection.createStatement();

            String szQuery = "";

            if (selection.equals("CriticalAlerts")) {
                szQuery = "select array_to_string(array_agg(summaryname),',') as ResourceNames,"
                        + "array_to_string(array_agg(summarycount),',') as ResourceValues,case when sum(criticalcheck)>0 "
                        + "then 'CRITICAL' else 'OK' end as Health from (select count(*) as summarycount,"
                        + "substring(task_summary from position('[' in task_summary) for 25) as summaryname, CASE WHEN "
                        + "substring(task_summary from position('[' in task_summary) for 25) like '%HSTDWN%' "
                        + "THEN 1 ELSE 0 END as criticalcheck from gatask where created_date between  '" + date + "' and '" + date1
                        + "' and status!='Closed' and task_type!='SOX' and customerid='" + cCustomer + "' and attributes4='" + service
                        + "' group by summaryname) as cAlert";
            } else if (selection.equals("AlertsByAssignee")) {
                szQuery = "select array_to_string(array_agg(assigneenames),',') as ResourceNames,"
                        + "array_to_string(array_agg(ticketcount),',') as ResourceValues,case when sum(ticketcount)>0 then 'CRITICAL' else 'OK' "
                        + "end as Health from (select count(*)as ticketcount,g1.assignee as assigneenames "
                        + "from gatask g2 ,gatasktypeassignee g1 where created_date between  '" + date + "' and '" + date1
                        + "' and g1.taskid=g2.task_id and action_assignee=1 and customerid='" + cCustomer + "' and attributes4='"
                        + service + "' group by g1.assignee) as assig";
            } else if (selection.equals("AlertsByStatus")) {
                szQuery = "select array_to_string(array_agg(statusnames),',') as ResourceNames,"
                        + "array_to_string(array_agg(statuscount),',') as ResourceValues,case when sum(statuscount)>0 then 'CRITICAL' else 'OK' "
                        + "end as Health from (select count(*) as statuscount,status as statusnames "
                        + "from gatask where created_date between  '" + date + "' and '" + date1
                        + "' and customerid='" + cCustomer + "' and attributes4='" + service + "' group by status) as sAlert";
            }

            /**
             * ***************************************************************************************************
             * This Query will give Modified result from all necessary tables
             * like gatasktypeassignee, gatask table .. here concatenating the
             * result came from GAtask for Summary Count and checking hostdown
             * status array_agg function in postgresql below 8 version we have
             * to create by following command: create aggregate array_agg (
             * sfunc = array_append, basetype = anyelement, stype = anyarray,
             * initcond = '{}' );
             * ***************************************************************************************************
             */
            System.out.println("Ticket Query /" + cCustomer + "/\n" + szQuery);
            log.debug("Ticket Query /" + cCustomer + "/\n" + szQuery);

            ResultSet rs = ConnectionDAO.executerQuery(szQuery, customer);//stat.executeQuery(szQuery);

            while (rs.next()) {
                String alertCount = "[]";
                String alertName = "";
                String alertHealth = "[]";
                String nameOfAlert = "";

                /**
                 * ************************************************************************************************
                 * Default Assignee that having no Ticket Assigned for specific
                 * host
                 * ************************************************************************************************
                 *
                 */
                String sz_query_assignee_list = "select distinct(user_id) as status from gaoperator where user_id !='Admin' "
                        + "and user_id!='None' and  user_id not in (select g1.assignee from gatask g2 ,"
                        + "gatasktypeassignee g1 where  created_date between '" + date + "' and '" + date1 + "'  and "
                        + "g1.taskid=g2.task_id and action_assignee=1 and customerid='" + cCustomer + "' and attributes4='" + service
                        + "') order by user_id";
                String assigneeList = getDefaultAssigneeStatus(sz_query_assignee_list, customer);

                /**
                 * Default Status for specific host
                 */
                String sz_query_status_list = " select distinct(status) as status from gastatus where status not in "
                        + "(select status from gatask where created_date between '" + date + "' and '" + date1
                        + "'  and customerid='" + cCustomer + "' and attributes4='" + service + "') order by status";
                String statusList = getDefaultAssigneeStatus(sz_query_status_list, customer);

                if (rs.getString("ResourceValues") != null) {
                    alertCount = "[" + rs.getString("ResourceValues") + "]";
                }
                if (rs.getString("ResourceNames") != null) {
                    alertName = "\'" + rs.getString("ResourceNames").replace(",", "\',\'") + "\'";
                }
                if (rs.getString("Health") != null) {
                    alertHealth = "[\"" + rs.getString("Health") + "\"]";
                }
                System.out.println("alertName==>>" + alertName);
                if (selection.equals("AlertsByAssignee")) {
                    if (alertName.equals("")) {
                        nameOfAlert = "[" + assigneeList.substring(1) + "]";
                    } else {
                        //nameOfAlert = "[" + alertName + assigneeList + "]";
                        String tmpName = alertName.replaceAll("\'", "\"");
                        nameOfAlert = "[" + tmpName + assigneeList + "]";
                    }

                } else if (selection.equals("AlertsByStatus")) {
                    if (alertName.equals("")) {
                        nameOfAlert = "[" + statusList.substring(1) + "]";
                    } else {
                        //nameOfAlert = "[" + alertName + statusList + "]";
                        String tmpName = alertName.replaceAll("\'", "\"");
                        nameOfAlert = "[" + tmpName + statusList + "]";
                    }

                }
                String summaryname1 = "";
                String summarynameconcat = "";

                /**
                 * **************************************************************************************************
                 * Default Task Summary accepted from properties: File name is
                 * TaskSummay.Properties For specific resourceType and Checking
                 * Task-Summary is present or not. if present then changing from
                 * the properties(MetricMapping.prperties) file
                 * **************************************************************************************************
                 */
                if (selection.equals("CriticalAlerts")) {

                    String[] splitsummaryname = alertName.split(",");
                    if (splitsummaryname.length > 0 && !splitsummaryname[0].equalsIgnoreCase("")) {
                        for (int b = 0; b < splitsummaryname.length; b++) {
                            System.out.println("splitsummaryname==>>" + splitsummaryname[b]);
                            /*if (resourceType.equals("server")) {
                             if (!splitsummaryname[b].toLowerCase().contains("fnsp") && !splitsummaryname[b].toLowerCase().contains("tem")) {
                             //System.out.println("183>>>>splitsummaryname[b] = " + splitsummaryname[b] + ", DBUtilHelper.getMetrics_mapping_properties().getProperty(splitsummaryname[b]) = " + DBUtilHelper.getMetrics_mapping_properties().getProperty(splitsummaryname[b]).trim());
                             summarynameconcat = summarynameconcat + ",\"" + DBUtilHelper.getMetrics_mapping_properties().getProperty(splitsummaryname[b]).trim() + "\"";
                             }
                             } else {*/
                            summarynameconcat = summarynameconcat + ",\"" + DBUtilHelper.getMetrics_mapping_properties().getProperty(splitsummaryname[b]).trim() + "\"";
                            //}
                        }

                        summarynameconcat = summarynameconcat.substring(1);
                        summaryname1 = summarynameconcat;
                    }

                    /**
                     * **************************************************************************************************
                     * Changing Task-Summary Name Present in
                     * Properties(TaskSummary.properties) with some useful
                     * meaning from other properties(MetricMapping.properties)
                     * files
                     * **************************************************************************************************
                     *
                     */
                    /*String[] szArrayCriticalNames = DBUtilHelper.getProperties().getProperty(resourceType).split(",");
                     for (int c = 0; c < szArrayCriticalNames.length; c++) {
                     if (!summaryname1.contains(DBUtilHelper.getMetrics_mapping_properties().getProperty(szArrayCriticalNames[c]).trim())) {
                     summaryname1 = summaryname1 + ",\"" + DBUtilHelper.getMetrics_mapping_properties().getProperty(szArrayCriticalNames[c]).trim() + "\"";
                     }
                     }*/
                }
                if (selection.equals("CriticalAlerts")) {
                    nameOfAlert = "[" + summaryname1 + "]";
                }

                /**
                 * Generating Map for Chart Generation
                 */
                ticketInfo.put(service, "\"ServiceName\":\"" + service + "\",\"ResourceNames\":" + nameOfAlert
                        + ",\"ResourceValues\":" + alertCount + ",\"SlaValues\":[10000],\"Health\":" + alertHealth);
                //ticketInfo.put(host+","+resourceId,"\"ServerName\":\""+host+"\",\"ServiceName\":\""+serviceName+"\",\"ResourceID\":\""+resourceId+"\",\"ResourceType\":\""+resourceType+"\",\"summarycount\":"+summarycount+",\"summaryname\":"+criticalSummaryName+",\"hstdwnstatus\":"+hstdwnstatus+",\"ticketcount\":"+ticketcount+",\"assigneenames\":"+assigneenames+",\"statusnames\":"+statusnames+",\"statuscount\":"+statuscount);
            }
            ConnectionDAO.closeStatement();

            if (ticketInfo.isEmpty()) {
                ticketInfo.put("DefaultMapValue", "\"summarycount\":[],\"summaryname\":[],\"hstdwnstatus\":[],\"ticketcount\":[],\"assigneenames\":[],\"statusnames\":[],\"statuscount\":[]");
            }
        } catch (Exception e) {
            e.printStackTrace();
            log.error("DashBoard Ticket Query /" + cCustomer + "/\n" + e.getMessage());
        } finally {
        }
        return ticketInfo;
    }

    private LinkedHashMap modifyHashMap(LinkedHashMap hm) {
        try {
            LinkedHashMap modifiedMap = new LinkedHashMap(hm);
            String chartType = "[\"0\",\"1\"]";
            String resourceId = "[\"Default\"]";
            Iterator hmKeySetItr = hm.keySet().iterator();
            System.out.println("Displaying HashMap");
            while (hmKeySetItr.hasNext()) {
                String szKey = hmKeySetItr.next().toString();
                System.out.println("key==>>" + szKey);
                String szValue = hm.get(szKey).toString();
                System.out.println("value==>>" + szValue);
                szValue += ",\"ResourceChartType\":" + chartType + ",\"ResourceNames\":" + resourceId;
                modifiedMap.remove(szKey);
                modifiedMap.put(szKey, szValue);
            }
            return modifiedMap;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public String generateWeatherJson(String resourceType, String cCustomer, String service,
            String startDate, String endDate, String timestampselection,
            String customer) {
        try {
            SimpleDateFormat formatter1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            Date dateStart = formatter1.parse(startDate);
            Date dateEnd = formatter1.parse(endDate);
            long smilli = dateStart.getTime() / 1000;
            long emilli = dateEnd.getTime() / 1000;
            serviceMetricInfo = new LinkedHashMap<String, String>();
            String szQueryMetric = "select t.metricvalue, t.metrictype from(select customerid,service,resourcetype,metrictype, "
                    + "max(timestamp1) as MaxTime from servicemetrics where resourcetype='Sensor' and metrictype in "
                    + "('Ambient_Temp','Irradiance','Wind_Speed','Module_Temp') and service='" + service + "' and customerid="
                    + "(select id from customerinfo where customername='" + cCustomer + "') and timestamp1 between " + smilli + "and "
                    + emilli + " group by customerid,service,metrictype,resourcetype) r inner join servicemetrics t on t.service=r.service and "
                    + "t.resourcetype=r.resourcetype and t.timestamp1 = r.MaxTime and t.metrictype=r.metrictype and "
                    + "t.customerid=r.customerid group by t.customerid,t.service,t.resourcetype,t.metrictype,t.metricvalue";

            String[] headingNamesMetric1 = {"MetricType", "MetricValue"};
            log.debug("Weather Query /" + timestampselection + "/ \n" + szQueryMetric);
            serviceMetricInfo = generateJsonFromGivenQuery(szQueryMetric, headingNamesMetric1, customer);
            log.info("Weather json hashmap==>>" + serviceMetricInfo.toString());
            String zWeatherJSON = createWeatherJSONFromHashMap(serviceMetricInfo);
            log.info("Weather json==>>" + zWeatherJSON);
            serviceMetricInfo = null;
            return zWeatherJSON;
        } catch (Exception e) {
            e.printStackTrace();
            log.error("Error in generateWeatherJson==>>" + e.getMessage());
        }
        return null;
    }

    public String generateCurrentSnapShotJson(String resourceType, String cCustomer, String service,
            String startDate, String endDate, String timestampselection,
            String customer) {
        try {
            SimpleDateFormat formatter1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            Date dateStart = formatter1.parse(startDate);
            Date dateEnd = formatter1.parse(endDate);
            long smilli = dateStart.getTime() / 1000;
            long emilli = dateEnd.getTime() / 1000;
            serviceMetricInfo = new LinkedHashMap<String, String>();
            String szQueryMetric = "select t.metricvalue, t.metrictype from(select customerid,service,resourcetype,metrictype, "
                    + "max(timestamp1) as MaxTime from servicemetrics where resourcetype=service and metrictype in "
                    + "('DayEnergy','YearEnergy','TotalEnergy','ACPower') and resourceid = service and service='" + service + "' and customerid="
                    + "(select id from customerinfo where customername='" + cCustomer + "') and timestamp1 between " + smilli + "and "
                    + emilli + " group by customerid,service,metrictype,resourcetype) r inner join servicemetrics t on t.service=r.service and "
                    + "t.resourcetype=r.resourcetype and t.timestamp1 = r.MaxTime and t.metrictype=r.metrictype and "
                    + "t.customerid=r.customerid group by t.customerid,t.service,t.resourcetype,t.metrictype,t.metricvalue";

            String[] headingNamesMetric1 = {"MetricType", "MetricValue"};
            log.debug("CurrentSnapShot Query /" + timestampselection + "/ \n" + szQueryMetric);
            serviceMetricInfo = generateJsonFromGivenQuery(szQueryMetric, headingNamesMetric1, customer);
            log.info("CurrentSnapShot json hashmap==>>" + serviceMetricInfo.toString());
            //derive PR,EPRP,CO2 saving===================================================================================================================
            String pr = "", eprp = "", co2saving = "";
            String szTemp = serviceMetricInfo.get("DayEnergy");
            if (szTemp != null) {
                String rem = "\"MetricValue\":\"";
                int startIndx = szTemp.lastIndexOf(rem) + rem.length();
                szTemp = szTemp.substring(startIndx, szTemp.length() - 1);
                Double dayEnergy = Double.parseDouble(szTemp);

                String confVal;
                Double val, confDVal;
                confVal = ResourceConfiguration.getConfValue(customer, cCustomer, service, null, "DCDayEnergy");
                if (confVal != null) {
                    confDVal = Double.parseDouble(confVal);
                    val = dayEnergy / confDVal;
                    DecimalFormat df = new DecimalFormat("#.##");
                    pr = pr + df.format(val) + ",";
                }

                confVal = ResourceConfiguration.getConfValue(customer, cCustomer, service, null, "InstalledCapacity");
                if (confVal != null) {
                    confDVal = Double.parseDouble(confVal);
                    val = dayEnergy / confDVal;
                    DecimalFormat df = new DecimalFormat("#.##");
                    eprp = eprp + df.format(val) + ",";
                }

                confVal = ResourceConfiguration.getConfValue(customer, cCustomer, service, null, "CO2Factor");
                if (confVal != null) {
                    confDVal = Double.parseDouble(confVal);
                    val = dayEnergy * confDVal;
                    DecimalFormat df = new DecimalFormat("#.##");
                    co2saving = co2saving + df.format(val) + ",";
                }
            }

            serviceMetricInfo.put("PerformanceRatio", "\"MetricType\":\"PerformanceRatio\",\"MetricValue\":\"" + pr + "\"");
            serviceMetricInfo.put("EnergyPerRatedPower", "\"MetricType\":\"EnergyPerRatedPower\",\"MetricValue\":\"" + eprp + "\"");
            serviceMetricInfo.put("CarbonSaving", "\"MetricType\":\"CarbonSaving\",\"MetricValue\":\"" + co2saving + "\"");
            //============================================================================================================================================
            String zCurrentSnapShotJSON = createCurrentSnapShotJSONFromHashMap(serviceMetricInfo);
            log.info("CurrentSnapShot json==>>" + zCurrentSnapShotJSON);
            serviceMetricInfo = null;
            return zCurrentSnapShotJSON;
        } catch (Exception e) {
            e.printStackTrace();
            log.error("Error in generateCurrentSnapShotJson==>>" + e.getMessage());
        }
        return null;
    }

    private String createWeatherJSONFromHashMap(LinkedHashMap hm) {
        try {
            String weatherJSON = "[{\"Now\": [";
            Iterator entryItr = hm.entrySet().iterator();
            while (entryItr.hasNext()) {
                Entry szHMEntry = (Entry) entryItr.next();
                String value = (String) szHMEntry.getValue();
                String rem = "\"MetricValue\":\"";
                int startIndx = value.lastIndexOf(rem) + rem.length();
                value = value.substring(startIndx, value.length() - 1);
                weatherJSON += "{\"name\":\"" + szHMEntry.getKey() + "\",\"value\":\"" + value + "\" },";
            }
            String lastCh = "" + weatherJSON.charAt(weatherJSON.length() - 1);
            if (lastCh.equals(",")) {
                weatherJSON = weatherJSON.substring(0, weatherJSON.length() - 1);
            }
            weatherJSON += "]},{\n"
                    + "        \"Forecast\": [\n"
                    + "\n"
                    + "                {\n"
                    + "                    \"name1\": \"Mon\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name2\": \"Tue\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name3\": \"Wed\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name4\": \"Thu\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name5\": \"Fri\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name6\": \"Sat\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name7\": \"Sun\"\n"
                    + "                }\n"
                    + "            ,\n"
                    + "\n"
                    + "                {\n"
                    + "                    \"name1\": \"28C\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name2\": \"32C\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name3\": \"26C\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name4\": \"22C\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name5\": \"24C\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name6\": \"26C\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name7\": \"24C\"\n"
                    + "                }\n"
                    + "            ,\n"
                    + "\n"
                    + "                {\n"
                    + "                    \"name1\": \"C\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name2\": \"R\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name3\": \"S\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name4\": \"PC\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name5\": \"C\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name6\": \"R\"\n"
                    + "                ,\n"
                    + "\n"
                    + "                    \"name7\": \"S\"\n"
                    + "                }\n"
                    + "]\n"
                    + "}\n"
                    + "]";
            return weatherJSON;
        } catch (Exception e) {
            e.printStackTrace();
            log.error("Error in createWeatherJSONFronHashMap==>>" + e.getMessage());
        }
        return "[]";
    }

    private String createCurrentSnapShotJSONFromHashMap(LinkedHashMap hm) {
        try {
            String snapshotJSON = "[";
            Iterator entryItr = hm.entrySet().iterator();
            while (entryItr.hasNext()) {
                Entry szHMEntry = (Entry) entryItr.next();
                String value = (String) szHMEntry.getValue();
                String rem = "\"MetricValue\":\"";
                int startIndx = value.lastIndexOf(rem) + rem.length();
                value = value.substring(startIndx, value.length() - 1);
                snapshotJSON += "{\"name\":\"" + szHMEntry.getKey() + "\",\"value\":\"" + value + "\" },";
            }
            String lastCh = "" + snapshotJSON.charAt(snapshotJSON.length() - 1);
            if (lastCh.equals(",")) {
                snapshotJSON = snapshotJSON.substring(0, snapshotJSON.length() - 1);
            }
            snapshotJSON += "]";
            return snapshotJSON;
        } catch (Exception e) {
            e.printStackTrace();
            log.error("Error in createCurrentSnapShotJSONFromHashMap==>>" + e.getMessage());
        }
        return "[]";
    }
}
